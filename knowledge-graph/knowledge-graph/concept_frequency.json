{
  "group": 4,
  "an infinite-dimensional object": 1,
  "objects": 8,
  "k \\otimes": 1,
  "the quantum universal enveloping algebra": 1,
  "quantum": 1,
  "functor": 8,
  "the coalgebra structure": 2,
  "\\dots": 1,
  "hopf": 2,
  "\\cong \\bigoplus_{k=|m-n|}^{m+n": 1,
  "\\otimes w": 1,
  "the jones polynomial": 1,
  "\\in b_n$": 1,
  "functors": 7,
  "the identity": 2,
  "whose lie algebra": 1,
  "g \\to gl(v)$": 1,
  "the representation category": 1,
  "quantum groups": 1,
  "## representation categories\n\na representation category": 1,
  "representation categories": 1,
  "coalgebra": 4,
  "kauffman": 1,
  "ribbon category structure": 1,
  "\\otimes": 4,
  "the algebraic structure": 2,
  "hopf algebra structure": 1,
  "this category": 3,
  "lie algebra g": 1,
  "this algebra": 1,
  "abstract algebra": 2,
  "repsu2": 1,
  "the appropriate algebraic structure": 1,
  "kauffman bracket": 1,
  "proof": 2,
  "endomorphism": 1,
  "sl(2,\u2102": 1,
  "the essential algebraic structure": 1,
  "finite-dimensional representations": 1,
  "\\dots$\n-": 1,
  "compact lie groups": 1,
  "a functor": 6,
  "g\n- morphisms": 1,
  "connection to the jones polynomial": 1,
  "the special unitary group": 1,
  "rmatrix": 1,
  "\\beta": 1,
  "groups": 4,
  "the endomorphism algebra": 1,
  ":\n\n- objects": 2,
  "full definition of u_qsl_2": 1,
  "temperley-lieb algebra": 1,
  "generators and relations": 1,
  "equivalence between repsu2 and finitedimensional representations of su2": 1,
  "a hopf algebra": 1,
  "the category": 4,
  "more algebraic flexibility": 1,
  "the universal enveloping algebra": 1,
  "category": 12,
  "morphisms": 6,
  "mathematical steps": 1,
  "why sl_2 instead of su2": 1,
  "representation categories and the jones polynomial": 1,
  "\\mathbb{c}(q)$": 1,
  "a group g": 2,
  "mathematical steps from repsu2 to the jones polynomial": 1,
  "jones": 1,
  "object": 10,
  "repsu2 vs repu_qsl_2": 1,
  "ef - fe": 1,
  "$n+1$\n   - the tensor product decomposition": 1,
  "lie": 2,
  "topological information": 1,
  "d\\rho(x": 1,
  "\\mapsto w \\otimes": 1,
  "algebra": 7,
  "the braid group representations": 1,
  "**representation category": 1,
  "natural isomorphism": 1,
  "repu_qsl_2": 1,
  "any lie group": 1,
  "a tensor category": 1,
  "isomorphism": 4,
  "- a braiding isomorphism": 1,
  "certain objects": 2,
  "the braid group": 1,
  "a ribbon category": 1,
  "**quantum groups": 1,
  "the quantum group $u_q(sl_2)$": 1,
  "its fundamental group": 1,
  "pauli": 1,
  "the algebraic relations": 1,
  "q^{-2}f$$": 1,
  "\\delta(e": 1,
  "identity": 6,
  "k^{-1}$": 1,
  "how representations of su2 extend to sl2\u2102": 1,
  "manim": 1,
  "category theory  adjoint functors chat session": 1,
  "adjoint functors": 1,
  ": adjunction": 1,
  "a classic adjunction perspective": 1,
  "importance:** adjunctions": 1,
  "text(\"\u03b7": 1,
  "curvedarrow(category_c.get_top": 1,
  "category_d.get_center": 1,
  "category_d": 1,
  "build": 1,
  "category_c.get_right": 1,
  "\"adjunctions": 1,
  "/ 2)\n\n        # build scene\n        self.play(create(category_c": 1,
  "an adjunction": 1,
  "self.play(growarrow(functor_f": 1,
  "vgroup": 1,
  "\"adjunction": 1,
  "self.play(growarrow(functor_g": 1,
  "# natural transformations": 1,
  "the terms \"adjoint functors": 1,
  "category_d.get_top": 1,
  "adjunction": 3,
  "functions": 8,
  "python manim": 1,
  "hom adjunctions": 1,
  "daniel kan": 1,
  "red": 1,
  "left": 1,
  "category theory": 9,
  "manim import *\n\nclass adjointfunctors(scene": 1,
  "create(category_d": 1,
  "curvedarrow(category_d.get_bottom": 1,
  "characteristic functions": 1,
  "adjunctions": 3,
  "natural transformations": 4,
  "text(\"\u03b5": 1,
  "adjoint_functors.py adjointfunctors": 1,
  "# category theory": 2,
  "circle(radius=1.5": 1,
  "$\\mathcal{d}$\n- natural transformations": 1,
  "two functors": 1,
  "uniqueness why it matters": 1,
  "algebraic topology": 1,
  "functional programming and category theory": 2,
  "all the expected algebraic properties": 1,
  "definition": 3,
  "```haskell": 2,
  "- pentagon identity": 1,
  "cartesian": 3,
  "construction": 1,
  "uniqueness": 1,
  "minimal composition structure": 1,
  "a new category": 1,
  "a monoidal functor": 1,
  "concrete example": 1,
  "a \\cong a$\n- functoriality": 1,
  "axioms": 4,
  "## answer\n\na free monoidal functor": 1,
  "vector spaces": 1,
  "the \"free monoidal category": 1,
  "the monoidal context": 1,
  "these isomorphisms": 1,
  "function": 9,
  "a monoid object": 1,
  "tensor types": 1,
  "monoidal laws": 1,
  "the free monoidal functor": 1,
  "a pedagogical approach\n\nunderstanding free monoidal functors": 1,
  "a monoidal functor\nmap": 1,
  "monoidal categories": 1,
  "the construction\n\nthe `list` functor": 1,
  "the insight build the minimal extension": 1,
  "why this works the coherence theorem": 1,
  "exactly the monoidal structure": 1,
  "the `list` functor": 1,
  "free monoid": 1,
  "list(a": 2,
  "the unique monoidal structure": 1,
  "relationship to free objects": 1,
  "the**\" free monoidal functor": 1,
  "the universal property": 1,
  "the free monoidal category": 1,
  "any two \"free monoidal extensions": 1,
  "any functor": 1,
  "a new target category": 1,
  "the correct interpretation": 1,
  "monoidal axioms": 1,
  "fold operations": 1,
  "isomorphic results": 1,
  "triangle": 2,
  "a \"free monoidal functor": 1,
  "the same functor": 1,
  "composition": 9,
  "maclane": 1,
  "free objects\n\nfree monoidal functors": 1,
  "the monoidal unit": 1,
  "(catamorphisms": 1,
  "pentagon": 2,
  "the monoidal structure": 2,
  "(the category": 1,
  "all morphisms": 1,
  "cartesian product": 2,
  "isomorphisms": 3,
  "coherence isomorphisms": 1,
  "a unique monoidal functor": 1,
  "the construction": 1,
  "applications and intuition": 1,
  "theorem": 1,
  "types": 7,
  "the monoidal category": 2,
  "answer": 3,
  "construction details": 1,
  "list(f": 2,
  "why this matters in programming": 1,
  "functor composition": 1,
  "free monoidal functors": 1,
  "alternative interpretation endofunctor perspective": 1,
  "**\n\nobjects": 1,
  "$d$\n- coherence isomorphisms": 1,
  "any base functor": 1,
  "monoidal coherence": 1,
  "monoid": 5,
  "free groups": 1,
  "a unique monoidal isomorphism": 1,
  "\\text{set}$": 1,
  "a group": 1,
  "endofunctor perspective": 1,
  "unique isomorphism": 1,
  "the inclusion functor": 1,
  ": objects": 1,
  "a monoidal category": 2,
  "any function": 1,
  "why this is free": 1,
  "the coherence theorem\n\nmaclane's coherence theorem": 1,
  "### uniqueness\n\nfree monoidal functors": 1,
  "catamorphisms": 2,
  "fold": 3,
  "objects factors": 1,
  "haskell": 7,
  "free monoidal functors a pedagogical approach": 1,
  "the **free monoidal functor": 1,
  "the identity functor": 1,
  "free monoidal functor fundamentals": 1,
  "# free monoidal functor fundamentals\n\n## question": 1,
  "monoidal functors": 1,
  "i_c)$": 1,
  "a free monoidal functor": 1,
  "any monoidal functor": 1,
  "endofunctors": 2,
  "- cartesian product": 1,
  "monoidal structure": 1,
  "question": 3,
  "any two objects": 2,
  "base functor": 1,
  "concrete example sets to vector spaces": 1,
  "the problem when functors dont preserve structure": 1,
  "coalgebra structure challenges": 1,
  "not traditional algebra operations": 1,
  "the group": 1,
  "the decomposition structure": 1,
  "proposed comultiplication": 1,
  "the abstract algebra sense": 1,
  "algebraic structure": 3,
  "the coalgebra gamma": 1,
  "decomposition": 1,
  "programming semantics": 1,
  "ab$": 1,
  "the algebra multiplication": 1,
  "a^*$": 1,
  "the algebra $a^*$": 1,
  "w'$": 1,
  "the solution": 1,
  "a coalgebra": 2,
  "### coalgebra structure": 1,
  "testing coassociativity": 1,
  "the axioms": 2,
  "exactly the coalgebra": 1,
  "coalgebras": 3,
  "\\text{tail}(w))$": 1,
  "morphism": 5,
  "the coalgebra": 2,
  "\\times$": 1,
  "| coalgebra": 1,
  "algebra operations clarification": 1,
  "fixed": 1,
  "algebras": 2,
  "proper coalgebra structure": 1,
  "\\epsilon)$": 1,
  "| concept | algebra": 1,
  "a free monoid": 1,
  "algebraic structure on a": 1,
  "an **initial algebra": 2,
  "k[a^*]$": 1,
  "a sum type": 2,
  "coalgebras in programming semantics": 1,
  "sum type": 1,
  "components": 1,
  "abstract algebra vs category theory": 1,
  "key concepts": 1,
  "the algebra a": 1,
  "|\n| purpose | construction | observation/decomposition": 1,
  "concept": 1,
  "* (category theory sense": 1,
  "the algebra structure map": 1,
  "**initial algebra": 1,
  "**abstract algebra coalgebra": 1,
  "\\alpha": 3,
  "\\gamma": 1,
  "the structure map alpha": 1,
  "group algebra": 1,
  "arrow": 1,
  "a proper coalgebra": 1,
  "attempt example": 1,
  "the fundamental issue": 1,
  "greatest": 1,
  "hopf algebras": 1,
  "\\langle": 1,
  "type": 8,
  "\\in": 2,
  "programming semantics notation for algebras and coalgebras": 1,
  "the pentagon": 1,
  "the triangle": 1,
  "a strict monoidal category": 1,
  "definition of colimits": 1,
  "not necessarily all small colimits": 1,
  "graph motif": 1,
  "identity morphisms": 1,
  "\\alpha$": 1,
  "a proof technique": 1,
  "examples": 2,
  "all finite colimits": 1,
  "some common types": 1,
  "a category": 4,
  "\\alpha_{a": 1,
  "colimit": 1,
  "\\otimes c \\to a \\otimes (b \\otimes c)$\n- $\\lambda$": 1,
  "key similarities": 1,
  "\\rho_a": 1,
  "three objects": 1,
  "computer science and type theory": 1,
  "all objects": 1,
  "- limits": 1,
  "a unique morphism": 1,
  "infinite colimits": 1,
  "\\lambda": 1,
  "**b) composition": 1,
  "lax monoidal categories": 1,
  "the triangle identity": 1,
  "latex": 2,
  "```\n\n### triangle identity": 1,
  "## answer\n\ncolimits": 1,
  "two non-identity morphisms": 1,
  "$\\lambda_a": 1,
  "finitely many objects": 1,
  "only up to coherent morphisms": 1,
  "examples of finite colimits": 1,
  "diagram chasing": 1,
  "intuitive understanding": 1,
  "its index category": 1,
  "comparison": 1,
  "an object": 5,
  "an isomorphism": 1,
  "not all small colimits": 1,
  "importance of diagrams": 1,
  "a small category": 1,
  "mathematical formalization": 1,
  "motifs": 1,
  "applications": 2,
  "a type": 3,
  "algebraic operations": 1,
  "feynman": 1,
  "four non-identity morphisms": 1,
  "e.g colimits": 1,
  "a natural transformation": 1,
  "natural transformation": 2,
  "triangle identity": 1,
  "a bifunctor": 1,
  "$\\lambda$": 1,
  "a logical order": 1,
  "specific types": 1,
  "key differences": 1,
  "why finite colimits": 1,
  "\"lax monoidal": 1,
  "category theory\n\n## question": 1,
  "a subgraph isomorphism problem": 1,
  "example comparison": 1,
  "strong monoidal categories": 1,
  "the identity morphism": 1,
  "\\to a_3 \\to \\cdots$": 1,
  "a distinguished object": 1,
  "a conversation on category theory": 1,
  "colimits in": 1,
  "the pentagon identity": 1,
  "a larger category": 1,
  "four objects": 1,
  "more pathological objects": 1,
  "the index category": 1,
  "$\\lambda": 1,
  "a more logical and coherent flow": 1,
  "all small colimits": 1,
  "finitely cocontinuous functors": 1,
  "pentagon identity": 1,
  "compositions": 3,
  "## pentagon identity": 1,
  "a colimit": 1,
  "algebraic structures": 1,
  "the monoidal operations": 1,
  "\\otimes$": 1,
  "infinite diagrams": 1,
  "colimits": 1,
  "strict monoidal categories": 1,
  "a lax monoidal category": 1,
  "a strong monoidal category": 1,
  "\\lambda$": 1,
  "data types": 2,
  "diagrams in other areas": 1,
  "shape category": 1,
  "c1\n```\n\n### triangle identity": 1,
  "these morphisms": 1,
  "two morphisms": 1,
  "## answer\n\na category": 1,
  "mere morphisms": 1,
  "limits": 3,
  "\\lambda_b$\"| b1": 1,
  "finite colimits": 1,
  "### pentagon identity": 1,
  "directed morphisms": 1,
  "index category": 1,
  "these fundamental category theory concepts": 1,
  "spans cospans limits and colimits in category theory": 1,
  "two objects": 1,
  "finite vs infinite diagrams": 1,
  "b \\otimes c)$": 1,
  "download_file(\"file1.txt": 1,
  "thread a": 1,
  "one thread handling multiple tasks": 1,
  "- object-oriented programming": 1,
  "- simple protein functions": 1,
  "these compositions": 1,
  "cpu": 1,
  "concurrency": 1,
  "the cell as a composable system": 1,
  "asyncio\nimport": 1,
  "the pattern": 1,
  "their functional identity": 1,
  "a given \"type": 1,
  "threading models": 1,
  "modeling biological systems": 1,
  "functional programming": 2,
  "a \"function": 1,
  "deadlocks": 1,
  "metabolic": 1,
  "mutable functional components": 1,
  "// outputs": 1,
  "reliable component composition": 1,
  "atp": 1,
  "reliable function": 1,
  "acid": 1,
  "why immutability helps composability": 1,
  "their structural/functional identity": 1,
  "reliable composition": 1,
  "immutability in cellular components": 1,
  "conclusion": 1,
  "a biological cell": 1,
  "other ways to achieve concurrency": 1,
  "race conditions": 1,
  "biological pathways": 1,
  "thread b": 1,
  "function instances": 1,
  "larger compositions": 1,
  "concurrency in computational systems": 1,
  "general patterns": 1,
  "output total time 20s": 1,
  "sequential execution": 1,
  "output total time 60s": 1,
  "their core function": 1,
  "composability without immutability": 1,
  "javascript": 1,
  "concurrent execution": 1,
  "clean composition": 1,
  "still concurrent but singlethreaded": 1,
  "immutable functional components": 1,
  "the relationship between composability and immutability": 1,
  "threading model": 1,
  "the cell as a computational system": 1,
  "concurrent multiple tasks at once": 1,
  "concurrency vs multithreading": 1,
  "compose": 1,
  "composability and data structure immutability": 1,
  "mutable objects\n- unix pipes": 1,
  "sequential": 1,
  "the \"catalase type": 1,
  "functional programming concepts": 1,
  "concrete example of concurrency": 1,
  "examples of concurrency without multithreading": 1,
  "key insights about composability": 1,
  "a function interface": 1,
  "sequential no concurrency": 1,
  "simulate": 1,
  "examples in practice": 1,
  "a \"type": 1,
  "other functors": 1,
  "the \"free monoid functor": 1,
  "the free monoid": 1,
  "right identity": 2,
  "left identity": 1,
  "f(x": 2,
  "the free monoid functor": 1,
  "a type constructor": 1,
  "all possible types": 1,
  "an endofunctor": 1,
  "the terminal object/unit type": 1,
  "categorical structure of finite lists": 1,
  "step 7 the list axioms": 1,
  "the same category": 1,
  "assistant": 2,
  "the \"list axioms": 1,
  "a morphism (function": 1,
  "the functor action": 1,
  "a \"type constructor": 1,
  "the type": 2,
  "some category": 1,
  "computable functions": 1,
  "the functor": 2,
  "step 4 the category were working in": 1,
  "monoid laws": 1,
  "the $list$ functor": 1,
  "those types": 1,
  "step 1 what are finite lists": 1,
  "step 2 lists as a type constructor": 1,
  "step 5 the algebraic structure of lists": 1,
  "introduction": 2,
  "step 6 why so much structure": 1,
  "$a$\n\nthese natural transformations": 1,
  "a function": 5,
  "another morphism": 1,
  "list$": 1,
  "(function": 1,
  "\\mathbf{set}$": 1,
  "g(s": 1,
  "general theorems": 1,
  "cons(y, xs": 1,
  "the monoid operation": 1,
  "list(b)$": 1,
  "list": 1,
  "the functorial picture": 2,
  "any type": 3,
  "human": 2,
  "- morphisms": 1,
  "new types": 1,
  "nil$": 1,
  "step 3 what makes list a functor": 1,
  "theorems": 1,
  "the list axioms": 1,
  "another object": 1,
  "list(f)([1,2,3": 1,
  "a new object\nperson": 1,
  "separate get/put functions": 1,
  "// suppose": 1,
  "string get(person person": 1,
  "textfield": 1,
  "address": 1,
  "making parts into objects": 1,
  "emailpart": 1,
  "our lens": 1,
  "the lenses": 1,
  "newvalue": 1,
  "= streetlens.liftvalidator(streetvalidator": 1,
  "string": 1,
  "where it actually matters dynamicgeneric scenarios": 1,
  "## coalgebraic lenses": 1,
  "a source object": 1,
  "immutability and composition": 1,
  "smart getters/setters](#lenses-as-smart": 1,
  "emaillens": 1,
  "fieldconfig(\"name": 1,
  "namelens": 1,
  "type s": 1,
  "original motivation": 1,
  "coalgebraic lenses": 1,
  "putput": 1,
  "java": 2,
  "namefield.gettext": 1,
  "new objects": 1,
  "this object": 1,
  "mutable objects": 1,
  "immutable objects": 1,
  "lenses": 2,
  "logic": 1,
  "one function": 1,
  "the ui connection logic": 1,
  "two functions": 1,
  "get(put(s": 1,
  "* haskell/clojure": 1,
  "a_2)$\n\nexample": 1,
  "the deeper need firstclass views and bidirectional transformations": 1,
  "functional programming languages": 1,
  "json": 1,
  "every possible field type": 1,
  "immutable composition": 1,
  "lenses](#original": 1,
  "[lenses": 1,
  "lens<s": 1,
  "lens\nvalidate(person": 1,
  "a more pedagogical version": 1,
  "composing functions": 2,
  "dynamic/generic scenarios": 1,
  "a \"lens": 1,
  "mathematical functions": 1,
  "optics step": 1,
  "coalgebras](#lenses": 1,
  "string newemail": 1,
  "some data\nlens<person": 1,
  "an object-oriented perspective": 1,
  "a \"coalgebra": 1,
  "the lens laws": 1,
  "why were lenses originally introduced": 1,
  "the lens": 2,
  "lens<person": 1,
  "lenses solution": 1,
  "every box object": 1,
  "[classical lenses": 1,
  "a single function": 1,
  "newstreet -> person.withstreet(newstreet": 1,
  "countrylens": 1,
  "different object": 1,
  "the original problem: nested immutable updates\nlenses": 1,
  "problem": 1,
  "lens": 2,
  "the update logic": 1,
  "newemail": 1,
  "serialize<s,a>(s object": 1,
  "optics": 2,
  "two separate functions": 1,
  "string newstreet": 1,
  "companyemaillens": 1,
  "pairs](#classical-lenses": 1,
  "the coalgebra perspective": 2,
  "immutable updates\nlenses": 1,
  "undo/redo:": 1,
  "wouldnt it be simpler just to use mutable objects instead": 1,
  "countrycodelens.set(person": 1,
  "a lens packages": 1,
  "coalgebraic lenses in category theory": 1,
  "field.lens.set(data": 1,
  "the classical functional programming sense": 1,
  "composition order": 1,
  "// handle": 1,
  "table of contents": 4,
  "newstreet": 1,
  "bidirectional transformations\nlenses": 1,
  "redrawui": 1,
  "any lens\nstreetfield.bindto(person": 1,
  "class configeditor {\n    void createform(object data": 1,
  "mutable composition](#immutable-vs-mutable-": 1,
  "string getstreet(person p": 1,
  "composable and first-class objects": 1,
  "newperson": 1,
  "a lens": 2,
  "fieldconfig": 1,
  "companystreetlens": 1,
  "any object": 1,
  "the key insight  lenses as coalgebras": 1,
  "the whole object\nvalidator<string> streetvalidator": 1,
  "an actual object": 1,
  "classical lenses": 1,
  "streetlens": 1,
  "mutable composition](#immutable-vs-mutable-composition": 1,
  "smart getters/setters](#lenses": 1,
  "getperson": 1,
  "step 1 lenses as smart getterssetters": 1,
  "generic code\n            textfield.settext(field.lens.get(data": 1,
  "standard function composition rules": 1,
  "step 1 classical lenses as getput pairs": 1,
  "the same validation logic": 1,
  "type a": 1,
  "functional composition": 1,
  "haskell\nfactorial": 1,
  "how to run": 1,
  "tail call optimization (tco": 1,
  "large integer string conversion limit\nsys.set_int_max_str_digits(50000": 1,
  "lists": 1,
  "macbook": 1,
  "analysis": 1,
  "recursionerror": 1,
  "performance benchmarks": 1,
  "/users/deepak/code/category-theory": 1,
  "foldl": 1,
  "timing function": 1,
  "haskell results": 1,
  "```haskell\n    factorial": 1,
  "### comparison": 1,
  "# haskell program": 1,
  "recursive factorial(10000": 1,
  "some simple haskell examples": 1,
  "factorial_iterative(n": 1,
  "naive recursive factorial(1000": 1,
  "homebrew": 1,
  "higherorder functions": 1,
  "tail recursive": 1,
  "a haskell program": 1,
  "-- function": 1,
  "multi-line functions": 1,
  "python3": 1,
  "haskell\nghci": 1,
  "a naive recursive function": 1,
  "-ssf https://get-ghcup.haskell.org": 1,
  "comparison to other languages": 1,
  "the optimized haskell versions": 1,
  "the limit": 1,
  "integer -> integer": 1,
  "the [official site](https://docs.haskellstack.org": 1,
  "haskell program factorial_tesths": 1,
  "increase limits for large number string conversion and recursion depth": 1,
  "their standard integer types": 1,
  "the haskell code": 1,
  "the factorial function": 1,
  "num": 1,
  "```haskell\nfactorial": 1,
  "pattern matching": 1,
  "a type signature": 1,
  "ghcup recommended": 1,
  "```haskell\n-- function composition\naddthendouble": 1,
  "haskell's `integer` type": 1,
  "a limited recursion depth": 1,
  "getting started": 1,
  "basic functions": 1,
  "getting started with haskell": 1,
  "stack": 1,
  "the haskell toolchain manager": 1,
  "any numeric type": 1,
  "python script factorial_testpy": 1,
  "limit": 2,
  "haskell's design": 1,
  "the `seq` function": 1,
  "\"/users/deepak/code/category-theory": 1,
  "a **tail-recursive** function": 1,
  "a type annotation": 1,
  "simple function": 1,
  "haskell code": 1,
  "map": 1,
  "cabal": 1,
  "stack alternative": 1,
  "certain types": 1,
  "ghc": 1,
  "### basic functions": 1,
  "integer string": 1,
  "a highly optimized built-in function": 1,
  "a simple recursive function": 1,
  "[ghc-39999]\n    \u2022 ambiguous type variable \u2018t0": 1,
  "download": 1,
  "```haskell\nghci": 1,
  "`haskell": 1,
  "## haskell": 1,
  "why recursion works so well in haskell": 1,
  "``haskell": 2,
  "python": 1,
  "fix for large integer string conversion limit": 1,
  "integer": 1,
  "haskell\n\n## question": 1,
  "many mathematical functions": 1,
  "haskell vs other languages": 1,
  "lazy evaluation": 1,
  "haskell\nimport system": 1,
  "just a normal function call\nlength": 1,
  "this limit": 1,
  "site](https://docs.haskellstack.org/en": 1,
  "why this is useful": 1,
  "monad laws function view": 1,
  "intuition": 1,
  "eugenio moggi": 1,
  "example functions\nhalf": 1,
  "monad": 1,
  "[maybe example (haskell)](#maybe-example-haskell": 1,
  "g \u2218": 1,
  "\"kleisli composition": 1,
  "a monad": 1,
  "coherence conditions": 1,
  "(haskell": 1,
  "function view)](#monad-laws-function-view": 1,
  "a new type": 1,
  "useful\nmonads": 1,
  "relationship to other concepts": 1,
  "monads": 1,
  "function view": 1,
  "the powerset functor": 1,
  "monadic values": 1,
  "a category c": 1,
  "basic idea": 1,
  "monadic composition behaves": 1,
  "a pure functional context\nsequencing computations": 1,
  "monadic composition": 1,
  "kleisli": 1,
  "intuitive explanation": 1,
  "these functions": 1,
  "a natural transformation \u03b7": 1,
  "maybe example haskell": 1,
  "philip wadler": 1,
  "## applications\nmonads": 1,
  "the maybe monad": 1,
  "a natural transformation \u03bc": 1,
  "monoid objects": 1,
  "the io monad": 1,
  "function composition": 1,
  "[monad laws": 1,
  "the monadic context": 1,
  "an identity": 1,
  "an endofunctor t": 1,
  "## monadic composition": 1,
  "the monad laws": 1,
  "## historical note\nmonads": 1,
  "that composition": 1,
  "## function composition view": 1,
  "what are monads": 1,
  "historical note": 1,
  "state": 2,
  "function composition view": 1,
  "the state monad": 1,
  "a monadic value": 1,
  "### monad laws": 1,
  "the endofunctor t": 1,
  "function composition problem": 1,
  "every adjunction": 1,
  "a) left identity": 1,
  "a type constructor m": 1,
  "a function return": 1,
  "the list functor": 2,
  "components in terms of functions": 1,
  "diagrams": 1,
  "\u2192 m b\n\n### function composition problem": 1,
  "## coherence conditions\na) left identity": 1,
  "[function composition view](#function-composition-view": 1,
  "the monadic composition operator": 1,
  "the yoneda lemma": 1,
  "our list type": 1,
  "optics\n\nthe coalgebra perspective": 1,
  "these decompositions": 1,
  "coalgebraic structure": 1,
  "step 6 why initial": 1,
  "engineering of programming": 1,
  "other data types": 1,
  "### assistant\n\nlenses": 1,
  "the familiar lens laws": 1,
  "this unique function": 1,
  "the profunctor representation": 1,
  "$$\nlens": 1,
  "a prism": 1,
  "clarke dyckhoff ghani": 1,
  "programming language connection": 1,
  "simple algebra operations": 1,
  "mathematical foundations": 1,
  "van laarhoven form": 1,
  "store": 1,
  "```haskell\ntype": 1,
  "* **structural induction**: proofs": 1,
  "van laarhoven and coalgebras": 1,
  "uncurry": 1,
  "traversals and distributive laws": 1,
  "profunctor": 1,
  "optics in": 1,
  "#### lenses": 1,
  "optics\" arxiv:1809.00738": 1,
  "initial algebras": 1,
  "the unit type": 1,
  "##### prisms": 1,
  "f(i)": 1,
  "distributive laws\n\ntraversals": 1,
  "b \\to s \\to s$": 1,
  "coalgebraic structures": 1,
  "```haskell\ntype optic p s t": 1,
  "profunctor optics": 1,
  "# store comonad": 1,
  "what are initial algebras": 1,
  "a\n  natfold z s = cata": 1,
  "natfold": 1,
  "\\pi_1": 1,
  "optics - complete reference list": 1,
  "* **affine traversals": 1,
  "the initial": 1,
  "the functor's output": 1,
  "the coalgebra perspective on optics": 1,
  "the sum function": 1,
  "a generalized fold": 1,
  "category theory connection": 1,
  "* morphism": 1,
  "any other $f$-algebra": 1,
  "the functorial picture of finite lists a stepbystep guide": 1,
  "##### traversals": 1,
  "the algebra structure": 1,
  "[a] -> b\n  foldr f z = cata": 1,
  "*category theory": 1,
  "step 8 the functorial perspectives benefits": 1,
  "f-algebras": 1,
  "* pickering gibbons wu \"profunctor optics": 1,
  "the functorial perspective's": 1,
  "infinite data": 1,
  "natural numbers": 1,
  "lenses and optics in category theory a discussion": 1,
  "prisms and coalgebras": 1,
  "the coalgebra laws": 1,
  "this functorial approach": 1,
  "polymorphic functions": 1,
  "\"universal coalgebra": 1,
  "traversals": 1,
  "the coalgebraic representation": 1,
  "\\circ lens": 1,
  "an algebra": 1,
  "computer science": 1,
  "optic": 1,
  "coalgebras\n\nprisms": 1,
  "optics - nasa/ads": 1,
  "lenses and": 1,
  "a = \\forall f. functor f => (a -> f a) -> (s -> f s": 1,
  "haskell symposium": 1,
  "a fold operation": 1,
  "potentially infinite, coinductively-defined types": 1,
  "bartosz milewski's": 1,
  "optics generalized": 1,
  "algebraic structure of setters": 1,
  "the catamorphism": 1,
  "correct fold operations": 1,
  "every inductive data type": 1,
  "$$\noptic~p~s": 1,
  "lens s": 1,
  "\\cong \\exists c.": 1,
  "references": 1,
  "store comonad": 2,
  "the corresponding inductive data type": 1,
  "step 3 the functor in action": 1,
  "* **coalgebra perspective": 1,
  "$$\nprism": 1,
  "foldr": 1,
  "chat session": 1,
  "rom\u00e1n": 1,
  "a unique function": 1,
  "other finite data types": 1,
  "define data types": 1,
  "many optics": 1,
  "step 2 representing the structure with a functor": 1,
  "data?](#why-initial-algebras": 1,
  "alpha": 1,
  "[the coalgebra perspective": 1,
  ": profunctor optics\" haskell symposium\n  * 0 results": 1,
  "a morphism": 1,
  "coalgebra theory": 1,
  "##### coalgebraic structure": 1,
  "other key papers\n  * optic": 1,
  "profunctor optics and coalgebras": 1,
  "# lenses": 1,
  "* **coalgebra theory": 1,
  "* **store comonad**:\n  * uustalu": 1,
  "vene": 1,
  "coalgebraic structure of getters": 1,
  "programming cafe": 1,
  "the algebra": 1,
  "catamorphism": 1,
  "the initial algebra $(list~a": 1,
  "primary sources": 1,
  "step 1 what we want to model": 1,
  "the data type": 1,
  "final coalgebras": 1,
  "why initial algebras for finite data": 1,
  "fold** operations": 1,
  "the van laarhoven representation": 1,
  "inductively-defined data types": 1,
  "the constructor function": 1,
  "j.j.m.m.": 1,
  "finite data": 1,
  "natf(x": 1,
  "list folding": 1,
  "\"profunctor optics": 1,
  "\\pi_2": 1,
  "finite data types": 1,
  "category theory background": 1,
  "listf(x)$": 1,
  "```haskell\ncata": 1,
  "the functorial perspective's benefits": 1,
  "\"profunctor optics categorical update": 1,
  "prism": 1,
  "powerful compositional tools": 1,
  "optics - nasa": 1,
  "where:\n\n```haskell\nsum_alg": 1,
  "step 9 other data types": 1,
  "step 7 concrete examples": 1,
  "elkins": 1,
  "$$\n\nthe store comonad": 1,
  "\"\n  * theoretical computer science, 249(1):3-80\n  * universal coalgebra": 1,
  "int, int": 1,
  "##### van laarhoven": 1,
  "a traversal": 1,
  "profunctors": 1,
  "nlab": 1,
  "step 5 the initial algebra": 1,
  "riley 2018": 1,
  "this coalgebraic structure": 1,
  "the container functor": 1,
  "additional resources": 1,
  "the initial algebra": 1,
  "the nlab optics page": 1,
  "the element type": 1,
  "the entire object": 1,
  "(co)algebra": 1,
  "\"finite data types": 1,
  "the sum functor": 1,
  "the initial algebra\n\nthe initial algebra": 1,
  "optics](#the-coalgebra-perspective": 1,
  "[category theory connection](#category-theory-connection": 1,
  "the unique morphism": 1,
  "key properties": 1,
  "traversal": 1,
  "step 4 finding the fixed point": 1,
  "\\to store": 1,
  "our target algebra": 1,
  "any polynomial functor": 1,
  "modular data accessors": 1,
  "store comonad and coalgebras": 1,
  "milewski": 1,
  "van laarhoven": 1,
  "#### optics": 1,
  "listf(x) \\to listf(y": 1,
  "the store comonad": 2,
  "the coalgebraic perspective": 1,
  "prisms": 1,
  "https://doi.org/10.22152/programming-journal.org/2017/1/7](https://doi.org/10.22152/programming-journal.org/2017/1/7": 1,
  "coalgebra literature": 1,
  "the fixed point\n\nhere's": 1,
  "yoneda": 2,
  "comonad": 2,
  "a morphism $\\alpha": 1,
  "any other algebra": 1,
  "a new function": 1,
  "category theory terms": 1,
  "the initial $f$-algebra": 1,
  "search results\n\n### category theory background\n\n* milewski": 1,
  "contrast with infinite data": 1,
  "an `optional`": 1,
  "universal coalgebra": 1,
  "= sum_alg (right (n, sum_list xs": 1,
  "finite lists example": 1,
  "an optic": 1,
  "##### profunctor optics": 1,
  "[why initial algebras": 1,
  "the broader category": 1,
  "group-representations": 1,
  "- the morphism sets": 1,
  "spatial slices": 1,
  "k-linear categories": 1,
  "a $k$-linear category": 1,
  "homomorphism": 1,
  "many 3d topological invariants": 1,
  "a name=\"adm-formalism-and-category-theory\"></a": 1,
  "what are klinear categories a namewhatareklinearcategoriesa": 1,
  "k$\n-": 1,
  "a compact lie group g": 1,
  "tqft and klinear categories a nametqftandklinearcategoriesa": 1,
  "quantum field theories\n\n## adm formalism and category theory": 1,
  "finite groups": 1,
  "both category theory": 1,
  "group representations](#category": 1,
  "adm": 1,
  "spacetime regions": 1,
  "riemannian metrics\nmorphisms": 1,
  "## category": 1,
  "topological invariance": 1,
  "the quantum group": 1,
  "the lie algebra": 1,
  "category of group representations a namecategoryofgrouprepresentationsa": 1,
  "linear": 1,
  "chern-simons": 1,
  "chern-simons theory": 1,
  "spatial 3-manifolds": 1,
  "formalism-and-category-theory": 1,
  "a functorial formalism": 1,
  "these objects": 1,
  "the functor structure": 1,
  "the group action": 1,
  "a modular tensor category": 1,
  "topological quantum field theory": 1,
  "a k-linear category": 1,
  "spin structures\nmorphisms": 1,
  "3-manifold invariants": 1,
  "introduction to klinear categories": 1,
  "general relativity": 1,
  "a group homomorphism": 1,
  "rep(uq(g": 1,
  "adm formalism and category theory a nameadmformalismandcategorytheorya": 1,
  "structured cobordisms": 1,
  "adm formalism": 1,
  "structured cobordisms a namestructuredcobordismsa": 1,
  "group representations": 1,
  "linear algebra": 1,
  "manifolds": 1,
  "reshetikhin-turaev construction: starts": 1,
  "2.2 types": 1,
  "universal construction": 1,
  "262\n18.1 adjunction": 1,
  "17.4 natural isomorphisms": 1,
  "contravariant functors": 1,
  "17.3 natural transformations": 1,
  "309\n311\n311\n313\n316\n317\n\n22 monads categorically\n318\n22.1 monoidal categories": 1,
  ".\n5.4 isomorphisms": 1,
  "optional": 1,
  "21.3 conclusion": 1,
  "a natural isomorphism": 1,
  "15.4 bibliography": 1,
  "242\n16 yoneda": 1,
  "5.1 initial object": 1,
  "113\n8.1 bifunctors": 1,
  "curry": 1,
  "3.5 monoid": 1,
  "211\n13.1 free monoid": 1,
  "4.2 writer": 1,
  "simple graphs": 1,
  "contents": 1,
  ".\n\n87\n\n7 functors\n7.1 functors": 1,
  "296\n21 monads": 1,
  "igal tabachnik": 1,
  "the maybe functor": 1,
  "165\n10.3 functor category": 1,
  "213\n13.2 free monoid universal construction": 1,
  "the hom-functor": 1,
  "all about morphisms\n254\n17.1 functors": 1,
  "116\n8.3 functorial algebraic data types": 1,
  "146\n147\n147\n148\n148\n149\n150\n150\n150\n153\n\n10 natural transformations\n154\n10.1 polymorphic functions": 1,
  "the essence of programming": 1,
  "7.1.4 typeclasses": 1,
  "7.2 functors": 1,
  "6.1 product types": 1,
  "323\n22.2 monoid": 1,
  "zeroth power": 1,
  "6.4 algebra": 1,
  "333\n23 comonads\n337\n23.1 programming": 1,
  "interactive input": 1,
  "monoids": 1,
  "the reader functor": 1,
  "329\n22.3 monads": 1,
  "219\n14 representable functors": 1,
  ". . . . . . . . . . . . . . . . . . . . . .\n5.2 terminal object": 1,
  "331\n22.4 monads": 1,
  "230\n15 the yoneda lemma": 1,
  "bartosz milewski": 1,
  "122\n8.5 the writer functor": 1,
  "14.4 bibliography": 1,
  "2.5 pure and dirty functions": 1,
  "coproduct bifunctors": 1,
  "19 free/forgetful adjunctions": 1,
  "338\n23.2 the product comonad": 1,
  "136\n9.2 currying": 1,
  "288\n20 monads": 1,
  "sum types": 1,
  "algebraic data types": 1,
  "first power": 1,
  "198\n12.3 colimits": 1,
  "17.6 hom-set isomorphisms": 1,
  "preorder example": 1,
  "notation": 1,
  "231\n15.1 yoneda": 1,
  "9.4\n9.5\n\n9.6\n9.7\n\ncartesian closed categories": 1,
  "the composition": 1,
  "340\n23.4 the stream comonad": 1,
  "the kleisli category": 1,
  "2\n2\n5\n8\n10\n\n2 types": 1,
  "comonads": 1,
  "263\n18.2 adjunctions": 1,
  "co-": 1,
  "3.4 monoid": 1,
  "the hom functor": 1,
  "curry-howard isomorphism": 1,
  "no objects": 1,
  "126\n8.7 profunctors": 1,
  "hom-sets": 1,
  "180\n\n12 limits": 1,
  "132\n9 function types": 1,
  "7.3 functor composition": 1,
  "category theory for programmers": 1,
  "118\n8.4 functors": 1,
  "one\n\n2\n\n1 category": 1,
  "6.3 sum types": 1,
  "209\niv\n\f13 free monoids": 1,
  "colimits\n188\n12.1 limit": 1,
  "7.1.5 functor": 1,
  "the writer category": 1,
  "1.3 composition": 1,
  "238\n15.2 co-yoneda": 1,
  "222\n14.2 representable functors": 1,
  "pdf": 1,
  "exponentials of exponentials": 1,
  "typeclasses": 1
}