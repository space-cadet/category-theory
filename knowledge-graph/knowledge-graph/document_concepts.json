{
  "Representation Categories and the Jones Polynomial": [
    "group",
    "an infinite-dimensional object",
    "objects",
    "k \\otimes",
    "the quantum universal enveloping algebra",
    "quantum",
    "functor",
    "the coalgebra structure",
    "\\dots",
    "hopf",
    "\\cong \\bigoplus_{k=|m-n|}^{m+n",
    "\\otimes w",
    "the jones polynomial",
    "\\in b_n$",
    "functors",
    "the identity",
    "whose lie algebra",
    "g \\to gl(v)$",
    "the representation category",
    "quantum groups",
    "## representation categories\n\na representation category",
    "representation categories",
    "coalgebra",
    "kauffman",
    "ribbon category structure",
    "\\otimes",
    "the algebraic structure",
    "hopf algebra structure",
    "this category",
    "lie algebra g",
    "this algebra",
    "abstract algebra",
    "repsu2",
    "the appropriate algebraic structure",
    "kauffman bracket",
    "proof",
    "endomorphism",
    "sl(2,\u2102",
    "the essential algebraic structure",
    "finite-dimensional representations",
    "\\dots$\n-",
    "compact lie groups",
    "a functor",
    "g\n- morphisms",
    "connection to the jones polynomial",
    "the special unitary group",
    "rmatrix",
    "\\beta",
    "groups",
    "the endomorphism algebra",
    ":\n\n- objects",
    "full definition of u_qsl_2",
    "temperley-lieb algebra",
    "generators and relations",
    "equivalence between repsu2 and finitedimensional representations of su2",
    "a hopf algebra",
    "the category",
    "more algebraic flexibility",
    "the universal enveloping algebra",
    "category",
    "morphisms",
    "mathematical steps",
    "why sl_2 instead of su2",
    "representation categories and the jones polynomial",
    "\\mathbb{c}(q)$",
    "a group g",
    "mathematical steps from repsu2 to the jones polynomial",
    "jones",
    "object",
    "repsu2 vs repu_qsl_2",
    "ef - fe",
    "$n+1$\n   - the tensor product decomposition",
    "lie",
    "topological information",
    "d\\rho(x",
    "\\mapsto w \\otimes",
    "algebra",
    "the braid group representations",
    "**representation category",
    "natural isomorphism",
    "repu_qsl_2",
    "any lie group",
    "a tensor category",
    "isomorphism",
    "- a braiding isomorphism",
    "certain objects",
    "the braid group",
    "a ribbon category",
    "**quantum groups",
    "the quantum group $u_q(sl_2)$",
    "its fundamental group",
    "pauli",
    "the algebraic relations",
    "q^{-2}f$$",
    "\\delta(e",
    "identity",
    "k^{-1}$",
    "how representations of su2 extend to sl2\u2102"
  ],
  "Exploring Adjoint Functors in Category Theory": [
    "category",
    "manim",
    "category theory  adjoint functors chat session",
    "adjoint functors",
    ": adjunction",
    "a classic adjunction perspective",
    "importance:** adjunctions",
    "text(\"\u03b7",
    "curvedarrow(category_c.get_top",
    "category_d.get_center",
    "category_d",
    "build",
    "category_c.get_right",
    "\"adjunctions",
    "/ 2)\n\n        # build scene\n        self.play(create(category_c",
    "an adjunction",
    "self.play(growarrow(functor_f",
    "vgroup",
    "\"adjunction",
    "self.play(growarrow(functor_g",
    "functors",
    "# natural transformations",
    "the terms \"adjoint functors",
    "category_d.get_top",
    "adjunction",
    "functions",
    "python manim",
    "hom adjunctions",
    "daniel kan",
    "red",
    "left",
    "category theory",
    "manim import *\n\nclass adjointfunctors(scene",
    "create(category_d",
    "curvedarrow(category_d.get_bottom",
    "characteristic functions",
    "adjunctions",
    "natural transformations",
    "text(\"\u03b5",
    "adjoint_functors.py adjointfunctors",
    "# category theory",
    "circle(radius=1.5",
    "$\\mathcal{d}$\n- natural transformations",
    "two functors"
  ],
  "Free Monoidal Functor Fundamentals": [
    "group",
    "uniqueness why it matters",
    "objects",
    "algebraic topology",
    "functional programming and category theory",
    "all the expected algebraic properties",
    "functor",
    "definition",
    "```haskell",
    "- pentagon identity",
    "cartesian",
    "construction",
    "uniqueness",
    "minimal composition structure",
    "a new category",
    "a monoidal functor",
    "concrete example",
    "functors",
    "a \\cong a$\n- functoriality",
    "axioms",
    "## answer\n\na free monoidal functor",
    "vector spaces",
    "the \"free monoidal category",
    "the monoidal context",
    "these isomorphisms",
    "function",
    "a monoid object",
    "tensor types",
    "monoidal laws",
    "the free monoidal functor",
    "natural transformations",
    "a pedagogical approach\n\nunderstanding free monoidal functors",
    "a monoidal functor\nmap",
    "monoidal categories",
    "the construction\n\nthe `list` functor",
    "the insight build the minimal extension",
    "why this works the coherence theorem",
    "\\otimes",
    "exactly the monoidal structure",
    "the `list` functor",
    "free monoid",
    "list(a",
    "the unique monoidal structure",
    "relationship to free objects",
    "the**\" free monoidal functor",
    "the universal property",
    "the free monoidal category",
    "any two \"free monoidal extensions",
    "any functor",
    "a new target category",
    "the correct interpretation",
    "monoidal axioms",
    "fold operations",
    "a functor",
    "isomorphic results",
    "triangle",
    "a \"free monoidal functor",
    "the same functor",
    "composition",
    "maclane",
    "groups",
    "free objects\n\nfree monoidal functors",
    "the monoidal unit",
    "(catamorphisms",
    "pentagon",
    "the monoidal structure",
    "(the category",
    "all morphisms",
    "cartesian product",
    "isomorphisms",
    "coherence isomorphisms",
    "a unique monoidal functor",
    "category",
    "the construction",
    "applications and intuition",
    "theorem",
    "morphisms",
    "types",
    "the monoidal category",
    "answer",
    "construction details",
    "list(f",
    "why this matters in programming",
    "functor composition",
    "free monoidal functors",
    "alternative interpretation endofunctor perspective",
    "**\n\nobjects",
    "$d$\n- coherence isomorphisms",
    "any base functor",
    "monoidal coherence",
    "monoid",
    "free groups",
    "object",
    "a unique monoidal isomorphism",
    "\\text{set}$",
    "a group",
    "endofunctor perspective",
    "unique isomorphism",
    "the inclusion functor",
    ": objects",
    "a monoidal category",
    "any function",
    "why this is free",
    "the coherence theorem\n\nmaclane's coherence theorem",
    "### uniqueness\n\nfree monoidal functors",
    "catamorphisms",
    "fold",
    "objects factors",
    "haskell",
    "free monoidal functors a pedagogical approach",
    "the **free monoidal functor",
    "the identity functor",
    "free monoidal functor fundamentals",
    "# free monoidal functor fundamentals\n\n## question",
    "monoidal functors",
    "i_c)$",
    "a free monoidal functor",
    "any monoidal functor",
    "isomorphism",
    "endofunctors",
    "- cartesian product",
    "monoidal structure",
    "question",
    "any two objects",
    "category theory",
    "base functor",
    "identity",
    "concrete example sets to vector spaces",
    "the problem when functors dont preserve structure"
  ],
  "Programming Semantics Notation for \"Algebras\" and \"Co-Algebras\"": [
    "category",
    "coalgebra structure challenges",
    "not traditional algebra operations",
    "group",
    "algebra",
    "the group",
    "\\otimes",
    "the decomposition structure",
    "proposed comultiplication",
    "the abstract algebra sense",
    "algebraic structure",
    "the coalgebra gamma",
    "decomposition",
    "programming semantics",
    "ab$",
    "the algebra multiplication",
    "a^*$",
    "the algebra $a^*$",
    "w'$",
    "hopf",
    "cartesian",
    "the solution",
    "a coalgebra",
    "### coalgebra structure",
    "testing coassociativity",
    "the axioms",
    "exactly the coalgebra",
    "coalgebras",
    "\\text{tail}(w))$",
    "morphism",
    "the coalgebra",
    "\\times$",
    "| coalgebra",
    "algebra operations clarification",
    "fixed",
    "monoid",
    "algebras",
    "object",
    "proper coalgebra structure",
    "\\epsilon)$",
    "| concept | algebra",
    "a free monoid",
    "algebraic structure on a",
    "an **initial algebra",
    "k[a^*]$",
    "axioms",
    "a sum type",
    "coalgebras in programming semantics",
    "sum type",
    "components",
    "abstract algebra vs category theory",
    "key concepts",
    "the algebra a",
    "|\n| purpose | construction | observation/decomposition",
    "concept",
    "* (category theory sense",
    "the algebra structure map",
    "**initial algebra",
    "**abstract algebra coalgebra",
    "\\alpha",
    "\\gamma",
    "category theory",
    "the structure map alpha",
    "group algebra",
    "arrow",
    "a proper coalgebra",
    "attempt example",
    "the fundamental issue",
    "coalgebra",
    "greatest",
    "cartesian product",
    "hopf algebras",
    "\\langle",
    "type",
    "\\in",
    "programming semantics notation for algebras and coalgebras"
  ],
  "When is a Category Lax Monoidal?": [
    "the pentagon",
    "the triangle",
    "a strict monoidal category",
    "objects",
    "definition of colimits",
    "not necessarily all small colimits",
    "functor",
    "definition",
    "graph motif",
    "identity morphisms",
    "\\alpha$",
    "a proof technique",
    "examples",
    "all finite colimits",
    "functors",
    "some common types",
    "axioms",
    "a category",
    "\\alpha_{a",
    "colimit",
    "\\otimes c \\to a \\otimes (b \\otimes c)$\n- $\\lambda$",
    "key similarities",
    "\\rho_a",
    "function",
    "three objects",
    "computer science and type theory",
    "all objects",
    "natural transformations",
    "- limits",
    "a unique morphism",
    "infinite colimits",
    "\\lambda",
    "**b) composition",
    "lax monoidal categories",
    "the triangle identity",
    "\\otimes",
    "latex",
    "```\n\n### triangle identity",
    "abstract algebra",
    "## answer\n\ncolimits",
    "two non-identity morphisms",
    "proof",
    "$\\lambda_a",
    "finitely many objects",
    "only up to coherent morphisms",
    "examples of finite colimits",
    "diagram chasing",
    "intuitive understanding",
    "a functor",
    "its index category",
    "triangle",
    "comparison",
    "an object",
    "composition",
    "groups",
    "an isomorphism",
    "not all small colimits",
    "pentagon",
    "importance of diagrams",
    "\\alpha",
    "a small category",
    "the category",
    "mathematical formalization",
    "motifs",
    "applications",
    "isomorphisms",
    "a type",
    "algebraic operations",
    "category",
    "type",
    "feynman",
    "four non-identity morphisms",
    "e.g colimits",
    "morphisms",
    "types",
    "a natural transformation",
    "the monoidal category",
    "natural transformation",
    "answer",
    "triangle identity",
    "a bifunctor",
    "$\\lambda$",
    "a logical order",
    "specific types",
    "key differences",
    "morphism",
    "object",
    "why finite colimits",
    "\"lax monoidal",
    "category theory\n\n## question",
    "a subgraph isomorphism problem",
    "example comparison",
    "strong monoidal categories",
    "the identity morphism",
    "\\to a_3 \\to \\cdots$",
    "a distinguished object",
    "a conversation on category theory",
    "colimits in",
    "the pentagon identity",
    "a larger category",
    "four objects",
    "more pathological objects",
    "the index category",
    "$\\lambda",
    "a more logical and coherent flow",
    "\\in",
    "all small colimits",
    "finitely cocontinuous functors",
    "pentagon identity",
    "compositions",
    "algebra",
    "## pentagon identity",
    "a colimit",
    "algebraic structures",
    "the monoidal operations",
    "\\otimes$",
    "infinite diagrams",
    "colimits",
    "strict monoidal categories",
    "a lax monoidal category",
    "a strong monoidal category",
    "\\lambda$",
    "data types",
    "diagrams in other areas",
    "isomorphism",
    "shape category",
    "c1\n```\n\n### triangle identity",
    "these morphisms",
    "two morphisms",
    "## answer\n\na category",
    "certain objects",
    "mere morphisms",
    "question",
    "limits",
    "\\lambda_b$\"| b1",
    "finite colimits",
    "category theory",
    "### pentagon identity",
    "directed morphisms",
    "identity",
    "index category",
    "these fundamental category theory concepts",
    "spans cospans limits and colimits in category theory",
    "two objects",
    "finite vs infinite diagrams",
    "b \\otimes c)$"
  ],
  "Composability and data structure immutability": [
    "download_file(\"file1.txt",
    "objects",
    "thread a",
    "one thread handling multiple tasks",
    "- object-oriented programming",
    "- simple protein functions",
    "these compositions",
    "cpu",
    "concurrency",
    "the cell as a composable system",
    "asyncio\nimport",
    "the pattern",
    "their functional identity",
    "a given \"type",
    "threading models",
    "modeling biological systems",
    "functional programming",
    "a \"function",
    "function",
    "deadlocks",
    "metabolic",
    "mutable functional components",
    "// outputs",
    "reliable component composition",
    "atp",
    "reliable function",
    "acid",
    "why immutability helps composability",
    "an object",
    "composition",
    "their structural/functional identity",
    "reliable composition",
    "immutability in cellular components",
    "conclusion",
    "a biological cell",
    "other ways to achieve concurrency",
    "race conditions",
    "biological pathways",
    "thread b",
    "function instances",
    "larger compositions",
    "concurrency in computational systems",
    "general patterns",
    "output total time 20s",
    "object",
    "sequential execution",
    "output total time 60s",
    "their core function",
    "composability without immutability",
    "javascript",
    "concurrent execution",
    "clean composition",
    "still concurrent but singlethreaded",
    "immutable functional components",
    "the relationship between composability and immutability",
    "threading model",
    "the cell as a computational system",
    "concurrent multiple tasks at once",
    "concurrency vs multithreading",
    "compose",
    "compositions",
    "composability and data structure immutability",
    "mutable objects\n- unix pipes",
    "haskell",
    "sequential",
    "the \"catalase type",
    "functional programming concepts",
    "functions",
    "concrete example of concurrency",
    "examples of concurrency without multithreading",
    "key insights about composability",
    "identity",
    "a function interface",
    "sequential no concurrency",
    "simulate",
    "examples in practice",
    "a \"type",
    "type"
  ],
  "Categorical Structure of Finite Lists": [
    "other functors",
    "the \"free monoid functor",
    "the free monoid",
    "objects",
    "right identity",
    "left identity",
    "functor",
    "f(x",
    "the free monoid functor",
    "a type constructor",
    "all possible types",
    "an endofunctor",
    "functors",
    "the terminal object/unit type",
    "the identity",
    "axioms",
    "a category",
    "function",
    "categorical structure of finite lists",
    "natural transformations",
    "step 7 the list axioms",
    "the same category",
    "assistant",
    "the algebraic structure",
    "this category",
    "list(a",
    "the \"list axioms",
    "a morphism (function",
    "the functor action",
    "a \"type constructor",
    "the type",
    "a functor",
    "some category",
    "computable functions",
    "the functor",
    "composition",
    "step 4 the category were working in",
    ":\n\n- objects",
    "monoid laws",
    "the $list$ functor",
    "those types",
    "the monoidal structure",
    "the category",
    "step 1 what are finite lists",
    "a type",
    "step 2 lists as a type constructor",
    "step 5 the algebraic structure of lists",
    "category",
    "introduction",
    "step 6 why so much structure",
    "morphisms",
    "types",
    "$a$\n\nthese natural transformations",
    "a function",
    "list(f",
    "another morphism",
    "list$",
    "the axioms",
    "(function",
    "morphism",
    "\\mathbf{set}$",
    "monoid",
    "object",
    "g(s",
    "general theorems",
    "cons(y, xs",
    "the monoid operation",
    "list(b)$",
    "list",
    "algebra",
    "the functorial picture",
    "any type",
    "human",
    "- morphisms",
    "new types",
    "nil$",
    "step 3 what makes list a functor",
    "theorems",
    "functions",
    "the list axioms",
    "category theory",
    "identity",
    "another object",
    "list(f)([1,2,3",
    "type"
  ],
  "Coalgebraic Lenses in Category Theory": [
    "a new object\nperson",
    "separate get/put functions",
    "objects",
    "// suppose",
    "string get(person person",
    "textfield",
    "address",
    "the coalgebra structure",
    "making parts into objects",
    "emailpart",
    "our lens",
    "the lenses",
    "newvalue",
    "= streetlens.liftvalidator(streetvalidator",
    "string",
    "where it actually matters dynamicgeneric scenarios",
    "## coalgebraic lenses",
    "a source object",
    "immutability and composition",
    "smart getters/setters](#lenses-as-smart",
    "emaillens",
    "fieldconfig(\"name",
    "namelens",
    "type s",
    "original motivation",
    "function",
    "coalgebraic lenses",
    "putput",
    "coalgebra",
    "java",
    "namefield.gettext",
    "new objects",
    "this object",
    "mutable objects",
    "immutable objects",
    "lenses",
    "logic",
    "one function",
    "the ui connection logic",
    "two functions",
    "get(put(s",
    "* haskell/clojure",
    "a_2)$\n\nexample",
    "the deeper need firstclass views and bidirectional transformations",
    "the coalgebra",
    "functional programming languages",
    "json",
    "every possible field type",
    "immutable composition",
    "lenses](#original",
    "[lenses",
    "lens<s",
    "lens\nvalidate(person",
    "an object",
    "a more pedagogical version",
    "composition",
    "composing functions",
    "dynamic/generic scenarios",
    "a \"lens",
    "mathematical functions",
    "optics step",
    "coalgebras](#lenses",
    "string newemail",
    "some data\nlens<person",
    "an object-oriented perspective",
    "a \"coalgebra",
    "the lens laws",
    "why were lenses originally introduced",
    "the lens",
    "lens<person",
    "lenses solution",
    "every box object",
    "[classical lenses",
    "a single function",
    "category",
    "introduction",
    "newstreet -> person.withstreet(newstreet",
    "countrylens",
    "types",
    "a function",
    "different object",
    "the original problem: nested immutable updates\nlenses",
    "problem",
    "lens",
    "the update logic",
    "coalgebras",
    "newemail",
    "serialize<s,a>(s object",
    "optics",
    "object",
    "two separate functions",
    "string newstreet",
    "companyemaillens",
    "pairs](#classical-lenses",
    "the coalgebra perspective",
    "immutable updates\nlenses",
    "undo/redo:",
    "wouldnt it be simpler just to use mutable objects instead",
    "countrycodelens.set(person",
    "a lens packages",
    "coalgebraic lenses in category theory",
    "field.lens.set(data",
    "the classical functional programming sense",
    "composition order",
    "// handle",
    "table of contents",
    "newstreet",
    "bidirectional transformations\nlenses",
    "redrawui",
    "haskell",
    "any lens\nstreetfield.bindto(person",
    "class configeditor {\n    void createform(object data",
    "mutable composition](#immutable-vs-mutable-",
    "string getstreet(person p",
    "composable and first-class objects",
    "newperson",
    "a lens",
    "any type",
    "fieldconfig",
    "companystreetlens",
    "any object",
    "the key insight  lenses as coalgebras",
    "the whole object\nvalidator<string> streetvalidator",
    "an actual object",
    "classical lenses",
    "streetlens",
    "mutable composition](#immutable-vs-mutable-composition",
    "functions",
    "smart getters/setters](#lenses",
    "getperson",
    "step 1 lenses as smart getterssetters",
    "generic code\n            textfield.settext(field.lens.get(data",
    "category theory",
    "standard function composition rules",
    "step 1 classical lenses as getput pairs",
    "the same validation logic",
    "type a",
    "functional composition",
    "type"
  ],
  "Getting Started with Haskell": [
    "haskell\nfactorial",
    "how to run",
    "tail call optimization (tco",
    "large integer string conversion limit\nsys.set_int_max_str_digits(50000",
    "lists",
    "```haskell",
    "macbook",
    "analysis",
    "recursionerror",
    "performance benchmarks",
    "/users/deepak/code/category-theory",
    "foldl",
    "timing function",
    "haskell results",
    "```haskell\n    factorial",
    "### comparison",
    "# haskell program",
    "function",
    "recursive factorial(10000",
    "some simple haskell examples",
    "java",
    "factorial_iterative(n",
    "naive recursive factorial(1000",
    "homebrew",
    "higherorder functions",
    "tail recursive",
    "a haskell program",
    "-- function",
    "multi-line functions",
    "python3",
    "haskell\nghci",
    "a naive recursive function",
    "-ssf https://get-ghcup.haskell.org",
    "comparison to other languages",
    "composition",
    "the optimized haskell versions",
    "the limit",
    "integer -> integer",
    "the [official site](https://docs.haskellstack.org",
    "haskell program factorial_tesths",
    "increase limits for large number string conversion and recursion depth",
    "their standard integer types",
    "the haskell code",
    "the factorial function",
    "num",
    "```haskell\nfactorial",
    "pattern matching",
    "category",
    "a type signature",
    "types",
    "answer",
    "ghcup recommended",
    "a function",
    "```haskell\n-- function composition\naddthendouble",
    "haskell's `integer` type",
    "a limited recursion depth",
    "getting started",
    "basic functions",
    "getting started with haskell",
    "stack",
    "the haskell toolchain manager",
    "any numeric type",
    "python script factorial_testpy",
    "limit",
    "haskell's design",
    "the `seq` function",
    "\"/users/deepak/code/category-theory",
    "a **tail-recursive** function",
    "a type annotation",
    "simple function",
    "haskell code",
    "map",
    "cabal",
    "stack alternative",
    "certain types",
    "ghc",
    "fold",
    "### basic functions",
    "haskell",
    "integer string",
    "a highly optimized built-in function",
    "a simple recursive function",
    "[ghc-39999]\n    \u2022 ambiguous type variable \u2018t0",
    "download",
    "```haskell\nghci",
    "`haskell",
    "## haskell",
    "why recursion works so well in haskell",
    "``haskell",
    "python",
    "fix for large integer string conversion limit",
    "integer",
    "haskell\n\n## question",
    "many mathematical functions",
    "haskell vs other languages",
    "question",
    "lazy evaluation",
    "functions",
    "limits",
    "haskell\nimport system",
    "just a normal function call\nlength",
    "this limit",
    "site](https://docs.haskellstack.org/en",
    "type"
  ],
  "Understanding Monads in Category Theory": [
    "why this is useful",
    "objects",
    "right identity",
    "monad laws function view",
    "functor",
    "definition",
    "intuition",
    "eugenio moggi",
    "algebraic structure",
    "example functions\nhalf",
    "monad",
    "[maybe example (haskell)](#maybe-example-haskell",
    "examples",
    "g \u2218",
    "\"kleisli composition",
    "a monad",
    "a category",
    "coherence conditions",
    "functional programming",
    "function",
    "(haskell",
    "function view)](#monad-laws-function-view",
    "a new type",
    "useful\nmonads",
    "relationship to other concepts",
    "monads",
    "adjunctions",
    "function view",
    "the powerset functor",
    "monadic values",
    "a category c",
    "basic idea",
    "monadic composition behaves",
    "a pure functional context\nsequencing computations",
    "monadic composition",
    "kleisli",
    "an object",
    "composition",
    "intuitive explanation",
    "these functions",
    "composing functions",
    "a natural transformation \u03b7",
    "maybe example haskell",
    "philip wadler",
    "## applications\nmonads",
    "the maybe monad",
    "the category",
    "applications",
    "a natural transformation \u03bc",
    "category",
    "monoid objects",
    "the io monad",
    "natural transformation",
    "function composition",
    "a function",
    "[monad laws",
    "the monadic context",
    "an identity",
    "an endofunctor t",
    "## monadic composition",
    "the monad laws",
    "monoid",
    "## historical note\nmonads",
    "object",
    "that composition",
    "## function composition view",
    "what are monads",
    "historical note",
    "state",
    "function composition view",
    "the state monad",
    "a monadic value",
    "### monad laws",
    "table of contents",
    "the endofunctor t",
    "function composition problem",
    "haskell",
    "every adjunction",
    "any type",
    "a) left identity",
    "endofunctors",
    "a type constructor m",
    "adjunction",
    "a function return",
    "functions",
    "the list functor",
    "components in terms of functions",
    "diagrams",
    "\u2192 m b\n\n### function composition problem",
    "category theory",
    "identity",
    "## coherence conditions\na) left identity",
    "[function composition view](#function-composition-view",
    "the monadic composition operator",
    "type"
  ],
  "Lenses and Optics in Category Theory": [
    "the yoneda lemma",
    "our list type",
    "optics\n\nthe coalgebra perspective",
    "these decompositions",
    "coalgebraic structure",
    "step 6 why initial",
    "engineering of programming",
    "other data types",
    "### assistant\n\nlenses",
    "the familiar lens laws",
    "this unique function",
    "functional programming and category theory",
    "the profunctor representation",
    "$$\nlens",
    "a prism",
    "algebraic structure",
    "functor",
    "clarke dyckhoff ghani",
    "programming language connection",
    "f(x",
    "simple algebra operations",
    "mathematical foundations",
    "van laarhoven form",
    "store",
    "```haskell\ntype",
    "* **structural induction**: proofs",
    "van laarhoven and coalgebras",
    "uncurry",
    "traversals and distributive laws",
    "profunctor",
    "optics in",
    "#### lenses",
    "optics\" arxiv:1809.00738",
    "initial algebras",
    "the unit type",
    "##### prisms",
    "f(i)",
    "distributive laws\n\ntraversals",
    "b \\to s \\to s$",
    "functors",
    "coalgebraic structures",
    "```haskell\ntype optic p s t",
    "profunctor optics",
    "# store comonad",
    "what are initial algebras",
    "a\n  natfold z s = cata",
    "natfold",
    "\\pi_1",
    "function",
    "optics - complete reference list",
    "* **affine traversals",
    "the initial",
    "the functor's output",
    "the coalgebra perspective on optics",
    "the sum function",
    "a generalized fold",
    "coalgebra",
    "category theory connection",
    "* morphism",
    "any other $f$-algebra",
    "the functorial picture of finite lists a stepbystep guide",
    "##### traversals",
    "the algebra structure",
    "[a] -> b\n  foldr f z = cata",
    "*category theory",
    "step 8 the functorial perspectives benefits",
    "f-algebras",
    "assistant",
    "* pickering gibbons wu \"profunctor optics",
    "the functorial perspective's",
    "lenses",
    "infinite data",
    "natural numbers",
    "lenses and optics in category theory a discussion",
    "prisms and coalgebras",
    "the coalgebra laws",
    "this functorial approach",
    "polymorphic functions",
    "\"universal coalgebra",
    "traversals",
    "the coalgebraic representation",
    "the type",
    "\\circ lens",
    "an algebra",
    "computer science",
    "optic",
    "coalgebras\n\nprisms",
    "optics - nasa/ads",
    "lenses and",
    "a = \\forall f. functor f => (a -> f a) -> (s -> f s",
    "a functor",
    "haskell symposium",
    "the functor",
    "a fold operation",
    "potentially infinite, coinductively-defined types",
    "an object",
    "bartosz milewski's",
    "optics generalized",
    "algebraic structure of setters",
    "the catamorphism",
    "correct fold operations",
    "every inductive data type",
    "$$\noptic~p~s",
    "lens s",
    "\\cong \\exists c.",
    "references",
    "store comonad",
    "\\alpha",
    "the corresponding inductive data type",
    "the lens",
    "step 3 the functor in action",
    "* **coalgebra perspective",
    "$$\nprism",
    "foldr",
    "chat session",
    "rom\u00e1n",
    "a unique function",
    "other finite data types",
    "a type",
    "define data types",
    "many optics",
    "step 2 representing the structure with a functor",
    "data?](#why-initial-algebras",
    "alpha",
    "category",
    "[the coalgebra perspective",
    "type",
    "types",
    ": profunctor optics\" haskell symposium\n  * 0 results",
    "a morphism",
    "coalgebra theory",
    "a function",
    "##### coalgebraic structure",
    "other key papers\n  * optic",
    "profunctor optics and coalgebras",
    "# lenses",
    "* **coalgebra theory",
    "* **store comonad**:\n  * uustalu",
    "vene",
    "lens",
    "coalgebraic structure of getters",
    "programming cafe",
    "the algebra",
    "catamorphism",
    "the initial algebra $(list~a",
    "primary sources",
    "step 1 what we want to model",
    "coalgebras",
    "morphism",
    "the data type",
    "final coalgebras",
    "why initial algebras for finite data",
    "optics",
    "algebras",
    "object",
    "fold** operations",
    "the van laarhoven representation",
    "inductively-defined data types",
    "the constructor function",
    "j.j.m.m.",
    "finite data",
    "an **initial algebra",
    "natf(x",
    "list folding",
    "a sum type",
    "\"profunctor optics",
    "\\pi_2",
    "finite data types",
    "category theory background",
    "listf(x)$",
    "```haskell\ncata",
    "the functorial perspective's benefits",
    "\"profunctor optics categorical update",
    "the coalgebra perspective",
    "prism",
    "powerful compositional tools",
    "optics - nasa",
    "where:\n\n```haskell\nsum_alg",
    "step 9 other data types",
    "step 7 concrete examples",
    "elkins",
    "$$\n\nthe store comonad",
    "\"\n  * theoretical computer science, 249(1):3-80\n  * universal coalgebra",
    "int, int",
    "##### van laarhoven",
    "a traversal",
    "profunctors",
    "nlab",
    "step 5 the initial algebra",
    "catamorphisms",
    "compositions",
    "algebra",
    "riley 2018",
    "this coalgebraic structure",
    "the container functor",
    "fold",
    "table of contents",
    "additional resources",
    "the initial algebra",
    "the nlab optics page",
    "the element type",
    "the functorial picture",
    "the entire object",
    "haskell",
    "(co)algebra",
    "\"finite data types",
    "the sum functor",
    "the initial algebra\n\nthe initial algebra",
    "a lens",
    "optics](#the-coalgebra-perspective",
    "[category theory connection](#category-theory-connection",
    "the unique morphism",
    "key properties",
    "a coalgebra",
    "traversal",
    "step 4 finding the fixed point",
    "human",
    "\\to store",
    "our target algebra",
    "any polynomial functor",
    "``haskell",
    "modular data accessors",
    "data types",
    "store comonad and coalgebras",
    "milewski",
    "van laarhoven",
    "#### optics",
    "listf(x) \\to listf(y",
    "the store comonad",
    "the coalgebraic perspective",
    "prisms",
    "https://doi.org/10.22152/programming-journal.org/2017/1/7](https://doi.org/10.22152/programming-journal.org/2017/1/7",
    "coalgebra literature",
    "functions",
    "the fixed point\n\nhere's",
    "yoneda",
    "comonad",
    "a morphism $\\alpha",
    "any other algebra",
    "a new function",
    "category theory terms",
    "the initial $f$-algebra",
    "search results\n\n### category theory background\n\n* milewski",
    "category theory",
    "contrast with infinite data",
    "an `optional`",
    "universal coalgebra",
    "= sum_alg (right (n, sum_list xs",
    "finite lists example",
    "an optic",
    "##### profunctor optics",
    "[why initial algebras",
    "the broader category"
  ],
  "Introduction to K-Linear Categories": [
    "group-representations",
    "category",
    "- the morphism sets",
    "spatial slices",
    "group",
    "k-linear categories",
    "algebra",
    "morphisms",
    "table of contents",
    "objects",
    "a $k$-linear category",
    "homomorphism",
    "many 3d topological invariants",
    "a name=\"adm-formalism-and-category-theory\"></a",
    "this category",
    "what are klinear categories a namewhatareklinearcategoriesa",
    "k$\n-",
    "functor",
    "a compact lie group g",
    "tqft and klinear categories a nametqftandklinearcategoriesa",
    "a group g",
    "quantum field theories\n\n## adm formalism and category theory",
    "finite groups",
    "both category theory",
    "group representations](#category",
    "adm",
    "spacetime regions",
    "riemannian metrics\nmorphisms",
    "## category",
    "topological invariance",
    "the quantum group",
    "the lie algebra",
    "morphism",
    "category of group representations a namecategoryofgrouprepresentationsa",
    "linear",
    "chern-simons",
    "chern-simons theory",
    "a functor",
    "spatial 3-manifolds",
    "formalism-and-category-theory",
    "a functorial formalism",
    "these objects",
    "the functor structure",
    "the group action",
    "composition",
    "functors",
    "a modular tensor category",
    "topological quantum field theory",
    "a k-linear category",
    "spin structures\nmorphisms",
    "3-manifold invariants",
    "introduction to klinear categories",
    "a category",
    "groups",
    "general relativity",
    "a group homomorphism",
    "rep(uq(g",
    "any two objects",
    "category theory",
    "adm formalism and category theory a nameadmformalismandcategorytheorya",
    "structured cobordisms",
    "adm formalism",
    "structured cobordisms a namestructuredcobordismsa",
    "lie",
    "group representations",
    "linear algebra",
    "manifolds",
    "reshetikhin-turaev construction: starts"
  ],
  "Milewski_Category Theory for Programmers_2014": [
    "2.2 types",
    "universal construction",
    "262\n18.1 adjunction",
    "17.4 natural isomorphisms",
    "contravariant functors",
    "17.3 natural transformations",
    "functor",
    "309\n311\n311\n313\n316\n317\n\n22 monads categorically\n318\n22.1 monoidal categories",
    ".\n5.4 isomorphisms",
    "optional",
    "cartesian",
    "21.3 conclusion",
    "a natural isomorphism",
    "15.4 bibliography",
    "242\n16 yoneda",
    "5.1 initial object",
    "113\n8.1 bifunctors",
    "curry",
    "3.5 monoid",
    "211\n13.1 free monoid",
    "4.2 writer",
    "simple graphs",
    "function",
    "contents",
    ".\n\n87\n\n7 functors\n7.1 functors",
    "296\n21 monads",
    "adjunctions",
    "igal tabachnik",
    "# category theory",
    "the maybe functor",
    "165\n10.3 functor category",
    "213\n13.2 free monoid universal construction",
    "the hom-functor",
    "all about morphisms\n254\n17.1 functors",
    "latex",
    "116\n8.3 functorial algebraic data types",
    "146\n147\n147\n148\n148\n149\n150\n150\n150\n153\n\n10 natural transformations\n154\n10.1 polymorphic functions",
    "the essence of programming",
    "7.1.4 typeclasses",
    "7.2 functors",
    "6.1 product types",
    "323\n22.2 monoid",
    "zeroth power",
    "6.4 algebra",
    "333\n23 comonads\n337\n23.1 programming",
    "interactive input",
    "monoids",
    "the reader functor",
    "329\n22.3 monads",
    "219\n14 representable functors",
    ". . . . . . . . . . . . . . . . . . . . . .\n5.2 terminal object",
    "composition",
    "331\n22.4 monads",
    "230\n15 the yoneda lemma",
    "bartosz milewski",
    "122\n8.5 the writer functor",
    "14.4 bibliography",
    "2.5 pure and dirty functions",
    "store comonad",
    "coproduct bifunctors",
    "19 free/forgetful adjunctions",
    "isomorphisms",
    "338\n23.2 the product comonad",
    "category",
    "136\n9.2 currying",
    "morphisms",
    "types",
    "288\n20 monads",
    "sum types",
    "algebraic data types",
    "first power",
    "198\n12.3 colimits",
    "17.6 hom-set isomorphisms",
    "preorder example",
    "limit",
    "monoid",
    "notation",
    "object",
    "231\n15.1 yoneda",
    "9.4\n9.5\n\n9.6\n9.7\n\ncartesian closed categories",
    "the composition",
    "340\n23.4 the stream comonad",
    "the kleisli category",
    "state",
    "2\n2\n5\n8\n10\n\n2 types",
    "comonads",
    "a monoidal category",
    "263\n18.2 adjunctions",
    "co-",
    "3.4 monoid",
    "the hom functor",
    "curry-howard isomorphism",
    "algebra",
    "no objects",
    "126\n8.7 profunctors",
    "haskell",
    "hom-sets",
    "180\n\n12 limits",
    "132\n9 function types",
    "7.3 functor composition",
    "category theory for programmers",
    "118\n8.4 functors",
    "one\n\n2\n\n1 category",
    "6.3 sum types",
    "isomorphism",
    "209\niv\n\f13 free monoids",
    "the store comonad",
    "colimits\n188\n12.1 limit",
    "adjunction",
    "functions",
    "the list functor",
    "7.1.5 functor",
    "yoneda",
    "comonad",
    "limits",
    "the writer category",
    "1.3 composition",
    "238\n15.2 co-yoneda",
    "222\n14.2 representable functors",
    "pdf",
    "exponentials of exponentials",
    "typeclasses"
  ]
}